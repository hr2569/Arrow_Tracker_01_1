import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Alert,
  Dimensions,
  Platform,
  Share,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { 
  getActiveCompetition, 
  setActiveCompetition,
  Competition,
} from '../utils/competitionStorage';
import * as Print from 'expo-print';
import * as FileSystem from 'expo-file-system';
import { TARGET_CONFIGS } from '../store/appStore';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function CompetitionSummaryScreen() {
  const router = useRouter();
  const [competition, setCompetition] = useState<Competition | null>(null);
  const [loading, setLoading] = useState(true);
  const [generating, setGenerating] = useState(false);

  const loadCompetition = async () => {
    try {
      setLoading(true);
      const comp = await getActiveCompetition();
      if (comp) {
        setCompetition(comp);
      }
    } catch (error) {
      console.error('Error loading competition:', error);
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      loadCompetition();
    }, [])
  );

  const handleFinish = async () => {
    await setActiveCompetition(null);
    router.replace('/');
  };

  // Generate text report for sharing
  const generateReportText = (): string => {
    if (!competition) return '';
    
    const archer = competition.participants[0];
    const targetConfig = TARGET_CONFIGS[competition.targetType as keyof typeof TARGET_CONFIGS];
    const maxScore = competition.maxRounds * competition.arrowsPerRound * 10;
    const percentage = Math.round((archer.totalScore / maxScore) * 100);
    
    let text = `üèÜ COMPETITION REPORT\n`;
    text += `${'‚ïê'.repeat(30)}\n\n`;
    text += `üìã ${competition.name || 'Competition'}\n`;
    text += `üë§ Archer: ${archer.name}\n`;
    text += `üìÖ Date: ${new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}\n`;
    text += `üéØ Target: ${targetConfig?.name || competition.targetType}\n`;
    text += `üìè Distance: ${competition.distance}\n\n`;
    
    text += `${'‚îÄ'.repeat(30)}\n`;
    text += `TOTAL SCORE: ${archer.totalScore}/${maxScore} (${percentage}%)\n`;
    text += `${'‚îÄ'.repeat(30)}\n\n`;
    
    text += `ROUND BREAKDOWN:\n`;
    archer.rounds.forEach((round, i) => {
      const arrows = round.shots.map(s => s.ring === 11 ? 'X' : s.ring === 10 ? '10' : s.ring === 0 ? 'M' : s.ring).join(' | ');
      text += `Round ${i + 1}: ${arrows} = ${round.totalScore}\n`;
    });
    
    text += `\n${'‚ïê'.repeat(30)}\n`;
    text += `Generated by Arrow Tracker`;
    
    return text;
  };

  // Share text report
  const handleShare = async () => {
    const reportText = generateReportText();
    
    try {
      if (Platform.OS === 'web') {
        await navigator.clipboard.writeText(reportText);
        alert('Report copied to clipboard!');
      } else {
        await Share.share({
          message: reportText,
          title: 'Competition Report',
        });
      }
    } catch (error) {
      console.error('Share error:', error);
    }
  };

  const getScoreBgColor = (score: number): string => {
    if (score === 11) return '#FFD700'; // X ring
    if (score >= 9) return '#FFD700';
    if (score >= 7) return '#ed1c24';
    if (score >= 5) return '#00a2e8';
    if (score >= 3) return '#2a2a2a';
    if (score >= 1) return '#f5f5f0';
    return '#333';
  };

  const getScoreTextColorHex = (score: number): string => {
    if (score === 11) return '#000'; // X ring
    if (score >= 9) return '#000';
    if (score >= 7) return '#fff';
    if (score >= 5) return '#fff';
    if (score >= 3) return '#fff';
    if (score >= 1) return '#000';
    return '#fff';
  };

  const generateHeatmapSvg = (shots: { x: number; y: number; ring: number }[], size: number, targetType: string): string => {
    const targetConfig = TARGET_CONFIGS[targetType as keyof typeof TARGET_CONFIGS];
    const rings = targetConfig?.rings || 10;
    const colors = targetConfig?.colors || [];
    
    // If no shots, show empty target
    if (shots.length === 0) {
      let ringsSvg = '';
      for (let i = 0; i < rings; i++) {
        const ringRatio = (rings - i) / rings;
        const ringSize = size * ringRatio * 0.95;
        const color = colors[i];
        ringsSvg += `
          <circle 
            cx="${size/2}" 
            cy="${size/2}" 
            r="${ringSize/2}" 
            fill="${color?.bg || '#f5f5f0'}" 
            stroke="${color?.border || '#333'}" 
            stroke-width="1"
          />
        `;
      }
      return `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
          ${ringsSvg}
          <text x="${size/2}" y="${size/2}" text-anchor="middle" fill="#666" font-size="14">No shots recorded</text>
        </svg>
      `;
    }
    
    // Create density grid for heatmap
    const gridSize = 50;
    const cellSize = size / gridSize;
    const densityGrid: number[][] = [];
    for (let i = 0; i < gridSize; i++) {
      densityGrid[i] = [];
      for (let j = 0; j < gridSize; j++) {
        densityGrid[i][j] = 0;
      }
    }
    
    // Calculate density with blur
    shots.forEach((shot) => {
      const gridX = Math.floor(shot.x * gridSize);
      const gridY = Math.floor(shot.y * gridSize);
      
      const blurRadius = 6;
      for (let dx = -blurRadius; dx <= blurRadius; dx++) {
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          const nx = gridX + dx;
          const ny = gridY + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const distance = Math.sqrt(dx * dx + dy * dy);
            const weight = Math.exp(-distance * distance / 8);
            densityGrid[ny][nx] += weight;
          }
        }
      }
    });
    
    let maxDensity = 0;
    densityGrid.forEach(row => {
      row.forEach(val => {
        if (val > maxDensity) maxDensity = val;
      });
    });
    
    // Color function
    const getHeatColor = (normalizedValue: number) => {
      if (normalizedValue === 0) return null;
      
      const colors = [
        { pos: 0, r: 0, g: 200, b: 0 },
        { pos: 0.33, r: 255, g: 255, b: 0 },
        { pos: 0.66, r: 255, g: 165, b: 0 },
        { pos: 1, r: 255, g: 0, b: 0 },
      ];
      
      let lower = colors[0];
      let upper = colors[colors.length - 1];
      
      for (let i = 0; i < colors.length - 1; i++) {
        if (normalizedValue >= colors[i].pos && normalizedValue <= colors[i + 1].pos) {
          lower = colors[i];
          upper = colors[i + 1];
          break;
        }
      }
      
      const range = upper.pos - lower.pos;
      const t = range === 0 ? 0 : (normalizedValue - lower.pos) / range;
      
      const r = Math.round(lower.r + t * (upper.r - lower.r));
      const g = Math.round(lower.g + t * (upper.g - lower.g));
      const b = Math.round(lower.b + t * (upper.b - lower.b));
      const opacity = 0.3 + normalizedValue * 0.5;
      
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    };
    
    // Generate target rings SVG
    let ringsSvg = '';
    for (let i = 0; i < rings; i++) {
      const ringRatio = (rings - i) / rings;
      const ringSize = size * ringRatio * 0.95;
      const color = colors[i];
      ringsSvg += `
        <circle 
          cx="${size/2}" 
          cy="${size/2}" 
          r="${ringSize/2}" 
          fill="${color?.bg || '#f5f5f0'}" 
          stroke="${color?.border || '#333'}" 
          stroke-width="1"
        />
      `;
    }
    
    // Generate heatmap cells
    let heatmapSvg = '';
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const density = densityGrid[y][x];
        if (density > 0) {
          const normalizedDensity = maxDensity > 0 ? density / maxDensity : 0;
          const heatColor = getHeatColor(normalizedDensity);
          if (heatColor) {
            const cellX = x * cellSize;
            const cellY = y * cellSize;
            // Only draw within target circle
            const distFromCenter = Math.sqrt(
              Math.pow(cellX + cellSize/2 - size/2, 2) + 
              Math.pow(cellY + cellSize/2 - size/2, 2)
            );
            if (distFromCenter < size * 0.475) {
              heatmapSvg += `<rect x="${cellX}" y="${cellY}" width="${cellSize + 1}" height="${cellSize + 1}" fill="${heatColor}" />`;
            }
          }
        }
      }
    }
    
    // Generate shot markers
    let shotsSvg = '';
    shots.forEach(shot => {
      const cx = shot.x * size;
      const cy = shot.y * size;
      shotsSvg += `
        <circle cx="${cx}" cy="${cy}" r="4" fill="rgba(255,255,255,0.9)" stroke="#000" stroke-width="1"/>
      `;
    });
    
    // Calculate mean point of impact
    if (shots.length > 0) {
      const meanX = shots.reduce((sum, s) => sum + s.x, 0) / shots.length * size;
      const meanY = shots.reduce((sum, s) => sum + s.y, 0) / shots.length * size;
      shotsSvg += `
        <circle cx="${meanX}" cy="${meanY}" r="8" fill="none" stroke="#00ff00" stroke-width="2"/>
        <line x1="${meanX - 10}" y1="${meanY}" x2="${meanX + 10}" y2="${meanY}" stroke="#00ff00" stroke-width="2"/>
        <line x1="${meanX}" y1="${meanY - 10}" x2="${meanX}" y2="${meanY + 10}" stroke="#00ff00" stroke-width="2"/>
      `;
    }
    
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg">
        ${ringsSvg}
        ${heatmapSvg}
        ${shotsSvg}
      </svg>
    `;
  };

  const generateScatterPlotSvg = (shots: { x: number; y: number; ring: number }[], size: number): string => {
    const padding = 30;
    const plotSize = size - padding * 2;
    
    // Grid lines
    let gridSvg = '';
    for (let i = 0; i <= 4; i++) {
      const pos = padding + (plotSize / 4) * i;
      gridSvg += `
        <line x1="${padding}" y1="${pos}" x2="${size - padding}" y2="${pos}" stroke="#333" stroke-width="1"/>
        <line x1="${pos}" y1="${padding}" x2="${pos}" y2="${size - padding}" stroke="#333" stroke-width="1"/>
      `;
    }
    
    // Axes
    const axisSvg = `
      <line x1="${padding}" y1="${size - padding}" x2="${size - padding}" y2="${size - padding}" stroke="#666" stroke-width="2"/>
      <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${size - padding}" stroke="#666" stroke-width="2"/>
      <text x="${size/2}" y="${size - 5}" text-anchor="middle" fill="#888" font-size="10">Horizontal</text>
      <text x="10" y="${size/2}" text-anchor="middle" fill="#888" font-size="10" transform="rotate(-90, 10, ${size/2})">Vertical</text>
    `;
    
    // Plot shots
    let shotsSvg = '';
    shots.forEach(shot => {
      const cx = padding + shot.x * plotSize;
      const cy = padding + shot.y * plotSize;
      shotsSvg += `
        <circle cx="${cx}" cy="${cy}" r="4" fill="#ed1c24" stroke="#000" stroke-width="1"/>
      `;
    });
    
    // Mean POI
    if (shots.length > 0) {
      const meanX = padding + (shots.reduce((sum, s) => sum + s.x, 0) / shots.length) * plotSize;
      const meanY = padding + (shots.reduce((sum, s) => sum + s.y, 0) / shots.length) * plotSize;
      shotsSvg += `
        <circle cx="${meanX}" cy="${meanY}" r="6" fill="none" stroke="#00ff00" stroke-width="2"/>
        <line x1="${meanX - 8}" y1="${meanY}" x2="${meanX + 8}" y2="${meanY}" stroke="#00ff00" stroke-width="2"/>
        <line x1="${meanX}" y1="${meanY - 8}" x2="${meanX}" y2="${meanY + 8}" stroke="#00ff00" stroke-width="2"/>
      `;
    }
    
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
        <rect x="${padding}" y="${padding}" width="${plotSize}" height="${plotSize}" fill="#111" stroke="#333"/>
        ${gridSvg}
        ${axisSvg}
        ${shotsSvg}
        <text x="${size/2}" y="${padding - 10}" text-anchor="middle" fill="#FFD700" font-size="12" font-weight="bold">Shot Distribution</text>
      </svg>
    `;
  };

  const generatePdfHtml = () => {
    if (!competition) return '';
    
    const archer = competition.participants[0];
    const targetConfig = TARGET_CONFIGS[competition.targetType as keyof typeof TARGET_CONFIGS];
    const allShots = archer.rounds.flatMap(r => r.shots);
    const maxPossibleScore = competition.maxRounds * competition.arrowsPerRound * 10;
    
    const heatmapSvg = generateHeatmapSvg(allShots, 250, competition.targetType);
    const scatterSvg = generateScatterPlotSvg(allShots, 250);

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Competition Report</title>
        <style>
          body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            padding: 30px;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
          }
          .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #8B0000;
          }
          .header h1 {
            color: #8B0000;
            margin: 0 0 5px 0;
            font-size: 28px;
          }
          .header .archer-name {
            font-size: 24px;
            color: #333;
            font-weight: bold;
            margin: 10px 0;
          }
          .header .meta {
            color: #666;
            font-size: 14px;
          }
          .total-score {
            text-align: center;
            background: linear-gradient(135deg, #1a1a1a, #333);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 30px;
          }
          .total-score .score {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
          }
          .total-score .max {
            font-size: 18px;
            color: #888;
          }
          .rounds-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
          }
          .rounds-table th {
            background: #8B0000;
            color: #fff;
            padding: 12px 8px;
            text-align: center;
            font-size: 14px;
          }
          .rounds-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
          }
          .rounds-table tr:nth-child(even) {
            background: #f9f9f9;
          }
          .rounds-table .round-total {
            font-weight: bold;
            background: #f0f0f0;
          }
          .charts-container {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
          }
          .chart-box {
            text-align: center;
          }
          .chart-box h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
          }
          .footer {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üèÜ COMPETITION REPORT</h1>
          <div class="archer-name">${archer.name}</div>
          <div class="meta">
            ${competition.name || 'Competition'} ‚Ä¢ ${new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}<br/>
            ${targetConfig?.name || competition.targetType} ‚Ä¢ ${competition.distance}
          </div>
        </div>

        <div class="total-score">
          <div class="score">${archer.totalScore}</div>
          <div class="max">out of ${maxPossibleScore} (${Math.round((archer.totalScore / maxPossibleScore) * 100)}%)</div>
        </div>

        <table class="rounds-table">
          <thead>
            <tr>
              <th>Round</th>
              <th>Arrow 1</th>
              <th>Arrow 2</th>
              <th>Arrow 3</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            ${archer.rounds.map((round, ri) => {
              const sortedShots = [...round.shots].sort((a, b) => b.ring - a.ring);
              return `
              <tr>
                <td><strong>${ri + 1}</strong></td>
                ${sortedShots.map(shot => `
                  <td style="background: ${getScoreBgColor(shot.ring)}; color: ${getScoreTextColorHex(shot.ring)}; font-weight: bold;">
                    ${shot.ring === 11 ? 'X' : shot.ring === 10 ? '10' : shot.ring === 0 ? 'M' : shot.ring}
                  </td>
                `).join('')}
                <td class="round-total">${round.totalScore}</td>
              </tr>
            `}).join('')}
            <tr style="background: #8B0000; color: #fff;">
              <td><strong>TOTAL</strong></td>
              <td colspan="3"></td>
              <td><strong>${archer.totalScore}</strong></td>
            </tr>
          </tbody>
        </table>

        <div class="charts-container">
          <div class="chart-box">
            <h3>Heat Map</h3>
            ${heatmapSvg}
          </div>
          <div class="chart-box">
            <h3>Shot Distribution</h3>
            ${scatterSvg}
          </div>
        </div>

        <div class="footer">
          Generated by Arrow Tracker ‚Ä¢ ${new Date().toLocaleString()}
        </div>
      </body>
      </html>
    `;
  };

  const generateCompetitionReport = async () => {
    if (!competition) return;

    setGenerating(true);
    
    if (Platform.OS === 'web') {
      // For web, open in new tab directly
      try {
        const html = generatePdfHtml();
        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
      } catch (error) {
        console.error('Web PDF error:', error);
        alert('Failed to open PDF. Please try again.');
      } finally {
        setGenerating(false);
      }
      return;
    }

    // Mobile - save directly
    try {
      const archer = competition.participants[0];
      const html = generatePdfHtml();

      const { uri } = await Print.printToFileAsync({ html });
      
      // Generate filename with date and archer name
      const dateStr = new Date().toISOString().split('T')[0];
      const archerNameClean = archer.name.replace(/[^a-zA-Z0-9]/g, '_');
      const filename = `Competition_${archerNameClean}_${dateStr}.pdf`;
      
      // Save to documents directory
      const documentsDir = FileSystem.documentDirectory;
      const destinationUri = `${documentsDir}${filename}`;
      
      await FileSystem.copyAsync({
        from: uri,
        to: destinationUri,
      });
      
      Alert.alert(
        'Report Saved',
        `Competition report saved as:\n${filename}`,
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('Error generating report:', error);
      Alert.alert('Error', 'Failed to generate report. Please try again.');
    } finally {
      setGenerating(false);
    }
  };

  if (loading || !competition) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>Loading...</Text>
        </View>
      </SafeAreaView>
    );
  }

  const archer = competition.participants[0];
  const maxPossibleScore = competition.maxRounds * competition.arrowsPerRound * 10;
  const percentage = Math.round((archer.totalScore / maxPossibleScore) * 100);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.headerSection}>
          <View style={styles.trophyContainer}>
            <Ionicons name="trophy" size={56} color="#FFD700" />
          </View>
          <Text style={styles.completedLabel}>Competition Complete!</Text>
          <Text style={styles.archerName}>{archer.name}</Text>
          <Text style={styles.competitionName}>{competition.name || 'Competition'}</Text>
        </View>

        {/* Score Display */}
        <View style={styles.scoreCard}>
          <Text style={styles.totalScore}>{archer.totalScore}</Text>
          <Text style={styles.maxScore}>out of {maxPossibleScore}</Text>
          <View style={styles.percentageBar}>
            <View style={[styles.percentageFill, { width: `${percentage}%` }]} />
          </View>
          <Text style={styles.percentageText}>{percentage}%</Text>
        </View>

        {/* Competition Info */}
        <View style={styles.infoRow}>
          <View style={styles.infoItem}>
            <Ionicons name="calendar-outline" size={16} color="#888" />
            <Text style={styles.infoText}>
              {new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}
            </Text>
          </View>
          <View style={styles.infoItem}>
            <Ionicons name="locate-outline" size={16} color="#888" />
            <Text style={styles.infoText}>{competition.distance}</Text>
          </View>
          <View style={styles.infoItem}>
            <Ionicons name="apps-outline" size={16} color="#888" />
            <Text style={styles.infoText}>{competition.maxRounds} rounds</Text>
          </View>
        </View>

        {/* Rounds Breakdown */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Round Breakdown</Text>
          <View style={styles.roundsContainer}>
            <View style={styles.roundsHeader}>
              <Text style={styles.roundsHeaderText}>Round</Text>
              <Text style={styles.roundsHeaderText}>Arrows</Text>
              <Text style={styles.roundsHeaderText}>Total</Text>
            </View>
            {archer.rounds.map((round, ri) => {
              // Sort shots from highest to lowest score for display
              const sortedShots = [...round.shots].sort((a, b) => b.ring - a.ring);
              return (
                <View key={ri} style={styles.roundRow}>
                  <Text style={styles.roundNumber}>{ri + 1}</Text>
                  <View style={styles.roundArrows}>
                    {sortedShots.map((shot, si) => (
                      <View
                        key={si}
                        style={[styles.arrowBadge, { backgroundColor: getScoreBgColor(shot.ring) }]}
                      >
                        <Text style={[styles.arrowText, { color: getScoreTextColorHex(shot.ring) }]}>
                          {shot.ring === 11 ? 'X' : shot.ring === 10 ? '10' : shot.ring === 0 ? 'M' : shot.ring}
                        </Text>
                      </View>
                    ))}
                  </View>
                  <Text style={styles.roundTotal}>{round.totalScore}</Text>
                </View>
              );
            })}
          </View>
        </View>
      </ScrollView>

      {/* Footer Actions */}
      <View style={styles.footer}>
        <TouchableOpacity style={styles.shareButton} onPress={handleShare}>
          <Ionicons name="share-social" size={20} color="#fff" />
          <Text style={styles.shareButtonText}>Share</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.reportButton}
          onPress={generateCompetitionReport}
          disabled={generating}
        >
          {generating ? (
            <Text style={styles.reportButtonText}>Saving...</Text>
          ) : (
            <>
              <Ionicons name="download-outline" size={20} color="#000" />
              <Text style={styles.reportButtonText}>Save PDF</Text>
            </>
          )}
        </TouchableOpacity>
        <TouchableOpacity style={styles.finishButton} onPress={handleFinish}>
          <Ionicons name="home" size={20} color="#fff" />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#000' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  loadingText: { color: '#888', fontSize: 16 },
  scrollView: { flex: 1 },
  scrollContent: { padding: 16 },
  headerSection: {
    alignItems: 'center',
    paddingVertical: 24,
  },
  trophyContainer: {
    width: 88,
    height: 88,
    borderRadius: 44,
    backgroundColor: 'rgba(255, 215, 0, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  completedLabel: {
    color: '#4CAF50',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  archerName: {
    color: '#fff',
    fontSize: 28,
    fontWeight: 'bold',
  },
  competitionName: {
    color: '#888',
    fontSize: 16,
    marginTop: 4,
  },
  scoreCard: {
    backgroundColor: '#111',
    borderRadius: 20,
    padding: 24,
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#222',
  },
  totalScore: {
    color: '#FFD700',
    fontSize: 64,
    fontWeight: 'bold',
  },
  maxScore: {
    color: '#666',
    fontSize: 16,
    marginBottom: 16,
  },
  percentageBar: {
    width: '100%',
    height: 8,
    backgroundColor: '#333',
    borderRadius: 4,
    overflow: 'hidden',
  },
  percentageFill: {
    height: '100%',
    backgroundColor: '#FFD700',
  },
  percentageText: {
    color: '#888',
    fontSize: 14,
    marginTop: 8,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: '#111',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
  },
  infoItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  infoText: {
    color: '#888',
    fontSize: 14,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  roundsContainer: {
    backgroundColor: '#111',
    borderRadius: 12,
    overflow: 'hidden',
  },
  roundsHeader: {
    flexDirection: 'row',
    backgroundColor: '#8B0000',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  roundsHeaderText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  roundRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#222',
  },
  roundNumber: {
    color: '#888',
    fontSize: 14,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  roundArrows: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 8,
  },
  arrowBadge: {
    width: 32,
    height: 32,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  arrowText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  roundTotal: {
    color: '#FFD700',
    fontSize: 16,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'center',
  },
  footer: {
    flexDirection: 'row',
    padding: 16,
    gap: 8,
    borderTopWidth: 1,
    borderTopColor: '#222',
  },
  shareButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#8B0000',
    paddingVertical: 14,
    borderRadius: 12,
    gap: 6,
  },
  shareButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  reportButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFD700',
    paddingVertical: 14,
    borderRadius: 12,
    gap: 6,
  },
  reportButtonText: {
    color: '#000',
    fontSize: 14,
    fontWeight: 'bold',
  },
  finishButton: {
    width: 48,
    height: 48,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#333',
    borderRadius: 12,
  },
  finishButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
