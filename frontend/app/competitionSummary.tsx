import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Alert,
  Dimensions,
  Platform,
  Share,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { 
  getActiveCompetition, 
  setActiveCompetition,
  Competition,
} from '../utils/competitionStorage';
import * as Print from 'expo-print';
import * as FileSystem from '../utils/fileSystemLegacy';
import { TARGET_CONFIGS } from '../store/appStore';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

export default function CompetitionSummaryScreen() {
  const router = useRouter();
  const [competition, setCompetition] = useState<Competition | null>(null);
  const [loading, setLoading] = useState(true);
  const [generating, setGenerating] = useState(false);

  const loadCompetition = async () => {
    try {
      setLoading(true);
      const comp = await getActiveCompetition();
      if (comp) {
        setCompetition(comp);
      }
    } catch (error) {
      console.error('Error loading competition:', error);
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      loadCompetition();
    }, [])
  );

  const handleFinish = async () => {
    await setActiveCompetition(null);
    router.replace('/');
  };

  // Generate text report for sharing
  const generateReportText = (): string => {
    if (!competition) return '';
    
    const archer = competition.participants[0];
    const targetConfig = TARGET_CONFIGS[competition.targetType as keyof typeof TARGET_CONFIGS];
    const maxScore = competition.maxRounds * competition.arrowsPerRound * 10;
    const percentage = Math.round((archer.totalScore / maxScore) * 100);
    
    let text = `üèÜ COMPETITION REPORT\n`;
    text += `${'‚ïê'.repeat(30)}\n\n`;
    text += `üìã ${competition.name || 'Competition'}\n`;
    text += `üë§ Archer: ${archer.name}\n`;
    text += `üìÖ Date: ${new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}\n`;
    text += `üéØ Target: ${targetConfig?.name || competition.targetType}\n`;
    text += `üìè Distance: ${competition.distance}\n`;
    if (archer.bowName) {
      text += `üèπ Bow: ${archer.bowName}\n`;
    }
    text += `\n`;
    
    text += `${'‚îÄ'.repeat(30)}\n`;
    text += `TOTAL SCORE: ${archer.totalScore}/${maxScore} (${percentage}%)\n`;
    text += `${'‚îÄ'.repeat(30)}\n\n`;
    
    text += `ROUND BREAKDOWN:\n`;
    archer.rounds.forEach((round, i) => {
      const arrows = round.shots.map(s => s.ring === 11 ? 'X' : s.ring === 10 ? '10' : s.ring === 0 ? 'M' : s.ring).join(' | ');
      text += `Round ${i + 1}: ${arrows} = ${round.totalScore}\n`;
    });
    
    text += `\n${'‚ïê'.repeat(30)}\n`;
    text += `Generated by Arrow Tracker`;
    
    return text;
  };

  // Share text report
  const handleShare = async () => {
    const reportText = generateReportText();
    
    try {
      if (Platform.OS === 'web') {
        await navigator.clipboard.writeText(reportText);
        alert('Report copied to clipboard!');
      } else {
        await Share.share({
          message: reportText,
          title: 'Competition Report',
        });
      }
    } catch (error) {
      console.error('Share error:', error);
    }
  };

  const getScoreBgColor = (score: number): string => {
    if (score === 11) return '#FFD700'; // X ring
    if (score >= 9) return '#FFD700';
    if (score >= 7) return '#ed1c24';
    if (score >= 5) return '#00a2e8';
    if (score >= 3) return '#2a2a2a';
    if (score >= 1) return '#f5f5f0';
    return '#333';
  };

  const getScoreTextColorHex = (score: number): string => {
    if (score === 11) return '#000'; // X ring
    if (score >= 9) return '#000';
    if (score >= 7) return '#fff';
    if (score >= 5) return '#fff';
    if (score >= 3) return '#fff';
    if (score >= 1) return '#000';
    return '#fff';
  };

  const generateHeatmapSvg = (shots: { x: number; y: number; ring: number }[], size: number, targetType: string): string => {
    // Match the session report heatmap style exactly
    if (shots.length === 0) {
      return `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="display: block; margin: 0 auto;" xmlns="http://www.w3.org/2000/svg">
          <rect width="${size}" height="${size}" fill="#f5f5f5" rx="8" />
          <text x="${size/2}" y="${size/2}" text-anchor="middle" fill="#666" font-size="14">No shots recorded</text>
        </svg>
      `;
    }

    const targetScale = 0.9;
    const targetSize = size * targetScale;
    
    // Grid for density calculation - HIGH RESOLUTION for smoothness
    const gridSize = 80;
    const cellSize = size / gridSize;
    const densityGrid: number[][] = [];
    for (let i = 0; i < gridSize; i++) {
      densityGrid[i] = [];
      for (let j = 0; j < gridSize; j++) {
        densityGrid[i][j] = 0;
      }
    }
    
    // Calculate density with larger blur for smoother gradients
    shots.forEach((shot) => {
      const gridX = Math.floor(shot.x * gridSize);
      const gridY = Math.floor(shot.y * gridSize);
      
      const blurRadius = 10;
      for (let dx = -blurRadius; dx <= blurRadius; dx++) {
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          const nx = gridX + dx;
          const ny = gridY + dy;
          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            const distance = Math.sqrt(dx * dx + dy * dy);
            const weight = Math.exp(-distance * distance / 16);
            densityGrid[ny][nx] += weight;
          }
        }
      }
    });
    
    let maxDensity = 0;
    densityGrid.forEach(row => {
      row.forEach(val => {
        if (val > maxDensity) maxDensity = val;
      });
    });
    
    // Color function matching session report
    const getHeatColor = (normalizedValue: number) => {
      if (normalizedValue === 0) return null;
      
      const colorStops = [
        { pos: 0, r: 0, g: 200, b: 0 },
        { pos: 0.33, r: 255, g: 255, b: 0 },
        { pos: 0.66, r: 255, g: 165, b: 0 },
        { pos: 1, r: 255, g: 0, b: 0 },
      ];
      
      let lower = colorStops[0];
      let upper = colorStops[colorStops.length - 1];
      
      for (let i = 0; i < colorStops.length - 1; i++) {
        if (normalizedValue >= colorStops[i].pos && normalizedValue <= colorStops[i + 1].pos) {
          lower = colorStops[i];
          upper = colorStops[i + 1];
          break;
        }
      }
      
      const range = upper.pos - lower.pos;
      const t = range === 0 ? 0 : (normalizedValue - lower.pos) / range;
      
      const r = Math.round(lower.r + (upper.r - lower.r) * t);
      const g = Math.round(lower.g + (upper.g - lower.g) * t);
      const b = Math.round(lower.b + (upper.b - lower.b) * t);
      const alpha = 0.4 + normalizedValue * 0.5;
      
      return { r, g, b, alpha };
    };

    // Generate heat circles with smoother rendering
    let heatCircles = '';
    densityGrid.forEach((row, y) => {
      row.forEach((density, x) => {
        if (density > 0.05) {
          const normalizedDensity = maxDensity > 0 ? density / maxDensity : 0;
          const color = getHeatColor(normalizedDensity);
          if (color) {
            const cx = x * cellSize + cellSize / 2;
            const cy = y * cellSize + cellSize / 2;
            const r = cellSize * 2.0;
            const alpha = color.alpha * Math.pow(normalizedDensity, 0.7);
            heatCircles += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})" />`;
          }
        }
      });
    });

    // Target ring colors based on target type
    const getTargetRingColors = () => {
      if (targetType === 'wa_standard') {
        return ['#f5f5f0', '#f5f5f0', '#2a2a2a', '#2a2a2a', '#00a2e8', '#00a2e8', '#ed1c24', '#ed1c24', '#fff200', '#fff200'];
      } else {
        return ['#00a2e8', '#00a2e8', '#ed1c24', '#ed1c24', '#fff200'];
      }
    };
    const ringColors = getTargetRingColors();
    
    // Generate target ring backgrounds
    let targetRingBgs = '';
    const numRings = targetType === 'wa_standard' ? 10 : 5;
    for (let ringNum = 1; ringNum <= numRings; ringNum++) {
      const diameterPercent = (numRings + 1 - ringNum) / numRings;
      const ringSize = targetSize * diameterPercent;
      const bgColor = ringColors[ringNum - 1] || '#fff200';
      targetRingBgs += `<circle cx="${size/2}" cy="${size/2}" r="${ringSize/2}" fill="${bgColor}" />`;
    }
    
    // Generate target ring outlines (drawn on top of heatmap)
    let targetRingLines = '';
    for (let ringNum = 1; ringNum <= numRings; ringNum++) {
      const diameterPercent = (numRings + 1 - ringNum) / numRings;
      const ringSize = targetSize * diameterPercent;
      let borderColor;
      if (targetType === 'wa_standard') {
        borderColor = ringNum <= 2 ? '#888' : ringNum <= 4 ? '#444' : ringNum <= 6 ? '#005090' : ringNum <= 8 ? '#901015' : '#907000';
      } else {
        borderColor = ringNum <= 2 ? '#005090' : ringNum <= 4 ? '#901015' : '#907000';
      }
      targetRingLines += `<circle cx="${size/2}" cy="${size/2}" r="${ringSize/2}" fill="none" stroke="${borderColor}" stroke-width="2" />`;
    }

    return `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="display: block; margin: 0 auto;" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <clipPath id="targetClip">
            <circle cx="${size/2}" cy="${size/2}" r="${targetSize/2}" />
          </clipPath>
        </defs>
        <!-- Target ring backgrounds -->
        ${targetRingBgs}
        <!-- Heatmap overlay (clipped to target area) -->
        <g clip-path="url(#targetClip)">
          ${heatCircles}
        </g>
        <!-- Target ring lines (on top of heatmap) -->
        ${targetRingLines}
        <!-- Center cross -->
        <line x1="${size/2 - 12}" y1="${size/2}" x2="${size/2 + 12}" y2="${size/2}" stroke="#000" stroke-width="2" />
        <line x1="${size/2}" y1="${size/2 - 12}" x2="${size/2}" y2="${size/2 + 12}" stroke="#000" stroke-width="2" />
      </svg>
    `;
  };

  // Generate Cartesian scatter plot SVG showing shot positions - matching session report style
  const generateScatterPlotSvg = (shots: { x: number; y: number; ring: number }[], size: number): string => {
    const padding = 60;
    const plotSize = size - padding * 2;
    const center = size / 2;
    
    if (shots.length === 0) {
      return `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="display: block; margin: 0 auto;" xmlns="http://www.w3.org/2000/svg">
          <rect x="${padding}" y="${padding}" width="${plotSize}" height="${plotSize}" fill="#fafafa" stroke="#ccc" stroke-width="1" />
          <text x="${center}" y="${center}" text-anchor="middle" fill="#666" font-size="14">No shot data</text>
        </svg>
      `;
    }
    
    // Grid lines
    let gridLines = '';
    const gridCount = 10;
    const gridStep = plotSize / gridCount;
    
    for (let i = 0; i <= gridCount; i++) {
      const pos = padding + i * gridStep;
      const opacity = i === gridCount / 2 ? 0.8 : 0.2;
      const strokeWidth = i === gridCount / 2 ? 2 : 1;
      gridLines += `<line x1="${pos}" y1="${padding}" x2="${pos}" y2="${size - padding}" stroke="#888" stroke-width="${strokeWidth}" opacity="${opacity}" />`;
      gridLines += `<line x1="${padding}" y1="${pos}" x2="${size - padding}" y2="${pos}" stroke="#888" stroke-width="${strokeWidth}" opacity="${opacity}" />`;
    }
    
    // Axis labels
    let axisLabels = '';
    const labelStep = 2;
    for (let i = 0; i <= gridCount; i += labelStep) {
      const pos = padding + i * gridStep;
      const value = ((i - gridCount / 2) / (gridCount / 2)).toFixed(1);
      axisLabels += `<text x="${pos}" y="${size - padding + 20}" text-anchor="middle" font-size="12" fill="#333">${value}</text>`;
      const yValue = (-(i - gridCount / 2) / (gridCount / 2)).toFixed(1);
      axisLabels += `<text x="${padding - 10}" y="${pos + 4}" text-anchor="end" font-size="12" fill="#333">${yValue}</text>`;
    }
    
    // Plot shots as dots with color based on ring score
    let shotDots = '';
    shots.forEach((shot) => {
      const normalizedX = (shot.x - 0.5) * 2;
      const normalizedY = (shot.y - 0.5) * 2;
      const svgX = center + normalizedX * (plotSize / 2);
      const svgY = center + normalizedY * (plotSize / 2);
      
      let dotColor = '#00a2e8';
      if (shot.ring >= 9 || shot.ring === 11) dotColor = '#FFD700';
      else if (shot.ring >= 7) dotColor = '#ed1c24';
      
      shotDots += `<circle cx="${svgX}" cy="${svgY}" r="5" fill="${dotColor}" stroke="#000" stroke-width="1" opacity="0.85" />`;
    });
    
    // Calculate mean point of impact
    const avgX = shots.reduce((sum, s) => sum + (s.x - 0.5) * 2, 0) / shots.length;
    const avgY = shots.reduce((sum, s) => sum + (s.y - 0.5) * 2, 0) / shots.length;
    const avgSvgX = center + avgX * (plotSize / 2);
    const avgSvgY = center + avgY * (plotSize / 2);
    
    const meanMarker = `
      <circle cx="${avgSvgX}" cy="${avgSvgY}" r="10" fill="none" stroke="#8B0000" stroke-width="3" />
      <line x1="${avgSvgX - 15}" y1="${avgSvgY}" x2="${avgSvgX + 15}" y2="${avgSvgY}" stroke="#8B0000" stroke-width="2" />
      <line x1="${avgSvgX}" y1="${avgSvgY - 15}" x2="${avgSvgX}" y2="${avgSvgY + 15}" stroke="#8B0000" stroke-width="2" />
    `;
    
    return `
      <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="display: block; margin: 0 auto;" xmlns="http://www.w3.org/2000/svg">
        <rect x="${padding}" y="${padding}" width="${plotSize}" height="${plotSize}" fill="#fafafa" stroke="#ccc" stroke-width="1" />
        ${gridLines}
        ${axisLabels}
        <text x="${center}" y="${size - 15}" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Horizontal (Left/Right)</text>
        <text x="15" y="${center}" text-anchor="middle" font-size="14" font-weight="bold" fill="#333" transform="rotate(-90, 15, ${center})">Vertical (Up/Down)</text>
        ${shotDots}
        ${meanMarker}
        <rect x="${size - 130}" y="${padding + 10}" width="120" height="90" fill="white" stroke="#ccc" rx="4" />
        <text x="${size - 120}" y="${padding + 28}" font-size="11" font-weight="bold" fill="#333">Legend</text>
        <circle cx="${size - 115}" cy="${padding + 45}" r="5" fill="#FFD700" stroke="#000" stroke-width="1" />
        <text x="${size - 105}" y="${padding + 49}" font-size="10" fill="#333">9-X (Gold)</text>
        <circle cx="${size - 115}" cy="${padding + 62}" r="5" fill="#ed1c24" stroke="#000" stroke-width="1" />
        <text x="${size - 105}" y="${padding + 66}" font-size="10" fill="#333">7-8 (Red)</text>
        <circle cx="${size - 115}" cy="${padding + 79}" r="5" fill="#00a2e8" stroke="#000" stroke-width="1" />
        <text x="${size - 105}" y="${padding + 83}" font-size="10" fill="#333">‚â§6 (Blue)</text>
        <text x="${size - 120}" y="${padding + 95}" font-size="9" fill="#8B0000">‚óè Mean POI: (${avgX.toFixed(2)}, ${(-avgY).toFixed(2)})</text>
      </svg>
    `;
  };

  const generatePdfHtml = () => {
    if (!competition) return '';
    
    const archer = competition.participants[0];
    const targetConfig = TARGET_CONFIGS[competition.targetType as keyof typeof TARGET_CONFIGS];
    const allShots = archer.rounds.flatMap(r => r.shots);
    const maxPossibleScore = competition.maxRounds * competition.arrowsPerRound * 10;
    
    // Use larger sizes to match session reports
    const heatmapSvg = generateHeatmapSvg(allShots, 500, competition.targetType);
    const scatterSvg = generateScatterPlotSvg(allShots, 500);

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Competition Report</title>
        <style>
          body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            padding: 30px;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
          }
          .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #8B0000;
          }
          .header h1 {
            color: #8B0000;
            margin: 0 0 5px 0;
            font-size: 28px;
          }
          .header .archer-name {
            font-size: 24px;
            color: #333;
            font-weight: bold;
            margin: 10px 0;
          }
          .header .meta {
            color: #666;
            font-size: 14px;
          }
          .total-score {
            text-align: center;
            background: linear-gradient(135deg, #1a1a1a, #333);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 30px;
          }
          .total-score .score {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
          }
          .total-score .max {
            font-size: 18px;
            color: #888;
          }
          .rounds-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
          }
          .rounds-table th {
            background: #8B0000;
            color: #fff;
            padding: 12px 8px;
            text-align: center;
            font-size: 14px;
          }
          .rounds-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #ddd;
            font-size: 14px;
          }
          .rounds-table tr:nth-child(even) {
            background: #f9f9f9;
          }
          .rounds-table .round-total {
            font-weight: bold;
            background: #f0f0f0;
          }
          .charts-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 30px;
            page-break-before: always;
          }
          .chart-box {
            text-align: center;
          }
          .chart-box h3 {
            margin: 0 0 10px 0;
            color: #8B0000;
            font-size: 18px;
            font-weight: bold;
          }
          .footer {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>üèÜ COMPETITION REPORT</h1>
          <div class="archer-name">${archer.name}</div>
          <div class="meta">
            ${competition.name || 'Competition'} ‚Ä¢ ${new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}<br/>
            ${targetConfig?.name || competition.targetType} ‚Ä¢ ${competition.distance}${archer.bowName ? ` ‚Ä¢ ${archer.bowName}` : ''}
          </div>
        </div>

        <div class="total-score">
          <div class="score">${archer.totalScore}</div>
          <div class="max">out of ${maxPossibleScore} (${Math.round((archer.totalScore / maxPossibleScore) * 100)}%)</div>
        </div>

        <table class="rounds-table">
          <thead>
            <tr>
              <th>Round</th>
              <th>Arrow 1</th>
              <th>Arrow 2</th>
              <th>Arrow 3</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody>
            ${archer.rounds.map((round, ri) => {
              const sortedShots = [...round.shots].sort((a, b) => b.ring - a.ring);
              return `
              <tr>
                <td><strong>${ri + 1}</strong></td>
                ${sortedShots.map(shot => `
                  <td style="background: ${getScoreBgColor(shot.ring)}; color: ${getScoreTextColorHex(shot.ring)}; font-weight: bold;">
                    ${shot.ring === 11 ? 'X' : shot.ring === 10 ? '10' : shot.ring === 0 ? 'M' : shot.ring}
                  </td>
                `).join('')}
                <td class="round-total">${round.totalScore}</td>
              </tr>
            `}).join('')}
            <tr style="background: #8B0000; color: #fff;">
              <td><strong>TOTAL</strong></td>
              <td colspan="3"></td>
              <td><strong>${archer.totalScore}</strong></td>
            </tr>
          </tbody>
        </table>

        <div class="charts-container">
          <div class="chart-box">
            <h3>Heat Map</h3>
            ${heatmapSvg}
          </div>
          <div class="chart-box">
            <h3>Shot Distribution</h3>
            ${scatterSvg}
          </div>
        </div>

        <div class="footer">
          Generated by Arrow Tracker ‚Ä¢ ${new Date().toLocaleString()}
        </div>
      </body>
      </html>
    `;
  };

  const generateCompetitionReport = async () => {
    if (!competition) return;

    setGenerating(true);
    
    if (Platform.OS === 'web') {
      // For web, open in new tab directly
      try {
        const html = generatePdfHtml();
        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
      } catch (error) {
        console.error('Web PDF error:', error);
        alert('Failed to open PDF. Please try again.');
      } finally {
        setGenerating(false);
      }
      return;
    }

    // Mobile - save directly
    try {
      const archer = competition.participants[0];
      const html = generatePdfHtml();

      const { uri } = await Print.printToFileAsync({ html });
      
      // Generate filename with date and archer name
      const dateStr = new Date().toISOString().split('T')[0];
      const archerNameClean = archer.name.replace(/[^a-zA-Z0-9]/g, '_');
      const filename = `Competition_${archerNameClean}_${dateStr}.pdf`;
      
      // Save to documents directory
      const documentsDir = FileSystem.documentDirectory;
      const destinationUri = `${documentsDir}${filename}`;
      
      await FileSystem.copyAsync({
        from: uri,
        to: destinationUri,
      });
      
      Alert.alert(
        'Report Saved',
        `Competition report saved as:\n${filename}`,
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('Error generating report:', error);
      Alert.alert('Error', 'Failed to generate report. Please try again.');
    } finally {
      setGenerating(false);
    }
  };

  if (loading || !competition) {
    return (
      <SafeAreaView style={styles.container}>
        <View style={styles.loadingContainer}>
          <Text style={styles.loadingText}>Loading...</Text>
        </View>
      </SafeAreaView>
    );
  }

  const archer = competition.participants[0];
  const maxPossibleScore = competition.maxRounds * competition.arrowsPerRound * 10;
  const percentage = Math.round((archer.totalScore / maxPossibleScore) * 100);

  return (
    <SafeAreaView style={styles.container}>
      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {/* Header Section */}
        <View style={styles.headerSection}>
          <View style={styles.trophyContainer}>
            <Ionicons name="trophy" size={56} color="#FFD700" />
          </View>
          <Text style={styles.completedLabel}>Competition Complete!</Text>
          <Text style={styles.archerName}>{archer.name}</Text>
          <Text style={styles.competitionName}>{competition.name || 'Competition'}</Text>
        </View>

        {/* Score Display */}
        <View style={styles.scoreCard}>
          <Text style={styles.totalScore}>{archer.totalScore}</Text>
          <Text style={styles.maxScore}>out of {maxPossibleScore}</Text>
          <View style={styles.percentageBar}>
            <View style={[styles.percentageFill, { width: `${percentage}%` }]} />
          </View>
          <Text style={styles.percentageText}>{percentage}%</Text>
        </View>

        {/* Competition Info */}
        <View style={styles.infoRow}>
          <View style={styles.infoItem}>
            <Ionicons name="calendar-outline" size={16} color="#888" />
            <Text style={styles.infoText}>
              {new Date(competition.completedAt || competition.createdAt).toLocaleDateString()}
            </Text>
          </View>
          <View style={styles.infoItem}>
            <Ionicons name="locate-outline" size={16} color="#888" />
            <Text style={styles.infoText}>{competition.distance}</Text>
          </View>
          <View style={styles.infoItem}>
            <Ionicons name="apps-outline" size={16} color="#888" />
            <Text style={styles.infoText}>{competition.maxRounds} rounds</Text>
          </View>
        </View>

        {/* Rounds Breakdown */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Round Breakdown</Text>
          <View style={styles.roundsContainer}>
            <View style={styles.roundsHeader}>
              <Text style={styles.roundsHeaderText}>Round</Text>
              <Text style={styles.roundsHeaderText}>Arrows</Text>
              <Text style={styles.roundsHeaderText}>Total</Text>
            </View>
            {archer.rounds.map((round, ri) => {
              // Sort shots from highest to lowest score for display
              const sortedShots = [...round.shots].sort((a, b) => b.ring - a.ring);
              return (
                <View key={ri} style={styles.roundRow}>
                  <Text style={styles.roundNumber}>{ri + 1}</Text>
                  <View style={styles.roundArrows}>
                    {sortedShots.map((shot, si) => (
                      <View
                        key={si}
                        style={[styles.arrowBadge, { backgroundColor: getScoreBgColor(shot.ring) }]}
                      >
                        <Text style={[styles.arrowText, { color: getScoreTextColorHex(shot.ring) }]}>
                          {shot.ring === 11 ? 'X' : shot.ring === 10 ? '10' : shot.ring === 0 ? 'M' : shot.ring}
                        </Text>
                      </View>
                    ))}
                  </View>
                  <Text style={styles.roundTotal}>{round.totalScore}</Text>
                </View>
              );
            })}
          </View>
        </View>
      </ScrollView>

      {/* Footer Actions */}
      <View style={styles.footer}>
        <TouchableOpacity style={styles.shareButton} onPress={handleShare}>
          <Ionicons name="share-social" size={20} color="#fff" />
          <Text style={styles.shareButtonText}>Share</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.reportButton}
          onPress={generateCompetitionReport}
          disabled={generating}
        >
          {generating ? (
            <Text style={styles.reportButtonText}>Saving...</Text>
          ) : (
            <>
              <Ionicons name="download-outline" size={20} color="#000" />
              <Text style={styles.reportButtonText}>Save PDF</Text>
            </>
          )}
        </TouchableOpacity>
        <TouchableOpacity style={styles.finishButton} onPress={handleFinish}>
          <Ionicons name="home" size={20} color="#fff" />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#000' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  loadingText: { color: '#888', fontSize: 16 },
  scrollView: { flex: 1 },
  scrollContent: { padding: 16 },
  headerSection: {
    alignItems: 'center',
    paddingVertical: 24,
  },
  trophyContainer: {
    width: 88,
    height: 88,
    borderRadius: 44,
    backgroundColor: 'rgba(255, 215, 0, 0.15)',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  completedLabel: {
    color: '#4CAF50',
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 8,
  },
  archerName: {
    color: '#fff',
    fontSize: 28,
    fontWeight: 'bold',
  },
  competitionName: {
    color: '#888',
    fontSize: 16,
    marginTop: 4,
  },
  scoreCard: {
    backgroundColor: '#111',
    borderRadius: 20,
    padding: 24,
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#222',
  },
  totalScore: {
    color: '#FFD700',
    fontSize: 64,
    fontWeight: 'bold',
  },
  maxScore: {
    color: '#666',
    fontSize: 16,
    marginBottom: 16,
  },
  percentageBar: {
    width: '100%',
    height: 8,
    backgroundColor: '#333',
    borderRadius: 4,
    overflow: 'hidden',
  },
  percentageFill: {
    height: '100%',
    backgroundColor: '#FFD700',
  },
  percentageText: {
    color: '#888',
    fontSize: 14,
    marginTop: 8,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: '#111',
    borderRadius: 12,
    padding: 16,
    marginBottom: 24,
  },
  infoItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  infoText: {
    color: '#888',
    fontSize: 14,
  },
  section: {
    marginBottom: 24,
  },
  sectionTitle: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12,
  },
  roundsContainer: {
    backgroundColor: '#111',
    borderRadius: 12,
    overflow: 'hidden',
  },
  roundsHeader: {
    flexDirection: 'row',
    backgroundColor: '#8B0000',
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  roundsHeaderText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  roundRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#222',
  },
  roundNumber: {
    color: '#888',
    fontSize: 14,
    fontWeight: '600',
    flex: 1,
    textAlign: 'center',
  },
  roundArrows: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center',
    gap: 8,
  },
  arrowBadge: {
    width: 32,
    height: 32,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  arrowText: {
    fontSize: 12,
    fontWeight: 'bold',
  },
  roundTotal: {
    color: '#FFD700',
    fontSize: 16,
    fontWeight: 'bold',
    flex: 1,
    textAlign: 'center',
  },
  footer: {
    flexDirection: 'row',
    padding: 16,
    gap: 8,
    borderTopWidth: 1,
    borderTopColor: '#222',
  },
  shareButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#8B0000',
    paddingVertical: 14,
    borderRadius: 12,
    gap: 6,
  },
  shareButtonText: {
    color: '#fff',
    fontSize: 14,
    fontWeight: 'bold',
  },
  reportButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFD700',
    paddingVertical: 14,
    borderRadius: 12,
    gap: 6,
  },
  reportButtonText: {
    color: '#000',
    fontSize: 14,
    fontWeight: 'bold',
  },
  finishButton: {
    width: 48,
    height: 48,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#333',
    borderRadius: 12,
  },
  finishButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
